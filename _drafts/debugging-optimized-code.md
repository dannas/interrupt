---
title: Debugging Optimized Code
description:
  Post Description (~140 words, used for discoverability and SEO)
author: tyler
image: img/<post-slug>/cover.png # 1200x630
---

One important tool for inspecting a program is a debugger.
Code without optimizations are generally easy to inspect but with optimizations,
the mapping between the source code and the machine instructions are not as straight forward.
Variables optimized out, lacking stack frames in back traces and unexpected jumps when debugging code,
is something we've all experienced.

With a bit of understanding of how the debug data is organized, how it is generated and what limitations exists,
I hope that your debugging efforts will be eased.

<!-- excerpt start -->

In this post we will explore how debugging information is generated by the compiler,
and how an optimizing compiler rearranges call flow, control flow, and data flow of
a program. 
We will do that building small snippets of C code and analyze various optimization steps.
Then, we will debug an example application using GDB.

<!-- excerpt end -->

TODO: Optional motivation to continue onwards

{% include newsletter.html %}

{% include toc.html %}

## What is needed from debugging information
We need to be able to map source lines to assembly instructions.
For each assembly instruction, there is one corresponding source line.
But a source line will for most expressions map to several assembly instruction.
And even mapping to the first assembly instruction has a 1:many mapping if the function has been inlined.

We need to map variables in a stack frame to memory locations or registers.
A variable has a source code scope and that scope may have been changed in the assembly.
A variable in the abstract C machine and when building without optimization has a memory location.
But for optimized code the location of the variable may change.
Sometimes the variable lives in a register, and then it's moved to a stack location.

We need to map functions to memory ranges, or rather the other way around.
Given this assembly instruction, how can I know which function it belongs to?

We need a way to traverse the call stack and know where we came from.
Given this stack location, which functions call frame am I inside?

## Example Project Setup
* STM32F4 Discovery board running emulated on Renode
* GDB 7.11.90 as our debugger
* GCC 9.2.1 / GNU Arm Embedded as our compiler
* GNU Make as our build system

## The DWARF data format
The DWARF debugging format is complex, with a specification weighing in at close to 500 pages.
It's complex since it's designed to cater to the needs of many different programming languages.
While originally designed for C, it's also used by C++, Fortran, Go, Swift, Rust, and many more.

The format is organized as a mostly tree-like graph. 
A Translation unit consists of types, line mappings and functions.
Functions consists of parameters and locals who consists of location lists.
The data takes up a lot of space.
Considerable space savings are achieved through a custom compression scheme.

The latest version of DWARF is version 5, published in 2017 and still considered experimental
Version 4, released in 2010, is the most common.
Version 3 from 2006, and version 2 from the late 1990s are also still in use.
TODO: Which versions of gcc supports which gdb version?
TODO: How do the versions differ

### DWARF gdb/gcc history

* gcc 10.1 (2020) 
* gcc 9.1 (2019) 
* gcc 8.1 (2018) Significantly improved debug info for LTO. DWARF now stores column info. https://gcc.gnu.org/gcc-8/changes.html
* gcc 7.1 (2017) DWARF5 supported but DWARF4 standard https://gcc.gnu.org/gcc-7/changes.html
* gcc 6.1 (2016)
* gcc 5.1 (2015)
* gcc 4.9 (2014)
* gcc 4.8 (2013) DWARF4 the default. Needs gdb 7.5. Before default was DWARF2. -Og added. https://gcc.gnu.org/gcc-4.8/changes.html
* gcc 4.7 (2012) Entry value, call site information, typed DWARF stack, compact macro representation https://gcc.gnu.org/gcc-4.7/changes.html . Needs gdb 7.4
* gcc 4.6 (2011) No significant changes 
* gcc 4.5 (2010) More features of DWARF3, and also some DWARF4 features. Need gdb 7.0 for full support https://gcc.gnu.org/gcc-4.5/changes.html
* gcc 4.4 (2009) No significant changes
* gcc 4.3 (2008) No significant changes

## Compiler optimizations

### Control flow optimizations
A compiler tries to canonicalize its input to make subsequent steps easier.
A while/for/do-while loop is typically turned into a do-while loop.

A guarded do-while is typically called loop inversion

Gcc with option -O2 generates guarded do loops
Gcc with option -O0 generates jump-to-middle (but g++ generates while)
Gcc with option -Os generates while statement, (if (...) break with jmp at end)
This is surprising: most compilers tries hard to keep loops on a do-while form.
That started with gcc 4.8 (the same release where -0g was introduced).
Before that, -Os used jump-to-middle
Clang generates guarded do-while for -Og, -O1, -Os, -O2
Clang generates while-loops for -O0

<iframe width="800px" height="200px" src="https://godbolt.org/e?readOnly=true&hideEditorToolbars=true#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhkAUgBMAISnTSAZ0ztkBPHUqZa6AMKpWAVwC2tQVvQAZPLUwA5YwCNMxEAE5SAB1QLC62nsMTQS8fNTorG3sjJxd3JRUw2gYCZmICAONTTkVlTFU/ZNSCCLtHZzdFFLSMoOyFKuLrUujy1wBKRVQDYmQOAHIpAGZrZEMsAGpxQZ169CwqADoEKexxAAYAQXWN6wJxhWNOCF3x5nEAVllzgBFSfbwAL0wAfT3bNsmAdllN8b/xk4KSaDa7jNZTH4bf7jGjEcYQHxPV4A4Gg8GDaQoqY6ca2CEAuRyD7ib7baHQoGEkGnC7SPAXa4Qsn/EmM37/YiYAjdWj7JmbVnbPodVggPrnPqkUx9NaS1BinSEmT7Lo9TCTSSDTiSghi2VtDoAaxAknOQjF3El0tlpHlfUlChAa1IuplwtIcFgSDQRg8eHYZAoEB9foDIFSRlckmyVH9BGcjogDj1koc1lSAE8xdrSD6jFoCAB5WisLNu0hYIwiYDsFMVvCc/IAN0wjvLmAAHnkDPHs5Ldso66w8A5iJm9Fg%2By7iHgjH2OjR6Ew2BwePxBMJRCglfJhw5HZAOqgPIk2wBaQs2%2BJ5RKabQ1LKkcwlKIxYLeXx0B/v0J%2BF9lFw6lyfI6EKap9EyQRrxApIGn/FpAMqIpvzqOCmlfcpOA6BRVV6LgRTFCUpTrO0NgAJQAWXGYBkGQcZXAWSQFk4eFaDoTAPggXBCBIDUtTuPRfX9Zw%2BKw8ZFRkOQdRTA1SGNU1zT6S1iPLO0HSdF0ZI9GBEBQVAhIDchKBDYSXAjKMYzjBNKGTcs01oTMpzzAti1LOtK2rWty3wRs1BbNsbU7btez6HMB1Fcs9zHYgMwnfocwIGc51C91F0YFhazXARJCEatt0kmQhBHA8ICPE8/HPQsFAdYDbwgcwUKfbR4LfbIQk/fwINqTwP0SFrMJyBICgaRroMSMDGkiACoJGrrH3qIp%2BsA7DcNXAjxStEixXIqiaLohimJYiA2JsTjuKIOEhmycT9NDEShkkD4JNkGRpLdWT5O4BZXB%2B36/r%2BgA2RTlOtOUxXU51XX1bT4Agb1btMozgwRsNzOjUhY1YeNiETWybXsxyUtzfT83oVyyxtDzRC8ymGxvPB/LrILkB7eL%2B3oQdIpHaLYowNnp1necMbodKVy4XgBEGXKtwkArd2K%2BAytPMUL0kGqho0er7zmsxmvQ6a2t6vxGvavr9YQqDauG5CdaAjXYMW83WqQ8DAnmtCpotrDOm6PDvYiojQdtbbKOo2j6MY5jWPYs78Au0SBJR%2B7NUGJ6dze/UjRNM0IpBrb7UUDSoeFda1ZUm01M096OhbHG/BAbggA%3D%3D%3D"></iframe>

loop:
	if (test-expr)
		goto out;
	body-statement;
	goto loop;
done:


## Mapping lines
Gcc marks source lines in the GIMPLE output using the `gimple_build_debug_begin_stmt` macro.
Gcc calls `gimple_build_debug_begin_stmt` from https://code.woboq.org/gcc/gcc/gimplify.c.html#11897 
Gcc uses `gimple_build_debug_bind` for marking variables.
These are inserted per compiler pass.

Objdump, gdb and gcc uses different code paths for displaying disasembly.

Objdump maps addresses to filenames and line numbers using the `.line_table`.
The line table is a matrix.
Objdump scans it looking for the last row that matches the address.
Objdump also keeps track of which lines have been seen in a file in the `print_file_list` struct.
It uses that to determine if lines preceeding the match should be printed or not.
It needs some extra logic in the face of inlined functions.

Gdb can show the line mapping using
```
(gdb) info line func
(gdb) info line *addr
```

Gdb can show assembly intermixed with source lines using the /m or /s options.
The /m option has been deprecated. It displays a source centric view, which is not very useful
The /s shows inlined functions from other files and provides a asm in pc access order
```
(gdb) disassemble /m func
(gdb) disassemble /s func
```

Gdb can determine where to place a breakpoint using...

Here is example output for  a contrived function `add2`.
Note how each statement is annotated in the gimple output.

<iframe width="800px" height="200px" src="https://godbolt.org/e?readOnly=true&hideEditorToolbars=true#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhkAUgBMAISnTSAZ0ztkBPHUqZa6AMKpWAVwC2tEAE5SW9ABk8tTADljAI0zFBAB1QLC62nsMTc1IvHzU6W3snI1d3TkVlTFU/BgJmYgIA41MLJRVw2lT0gkjHFzdBBTSMrKDc6pK7MpiKzgBKRVQDYmQOAHI7AgBqZnR0SQhBoYAPNqHxAHZZAAYAQSGNmfmAZgARLbkhznFtlfXN6Z39y8Pj0/E1zaHiTAJu2hmTs8Xdvo7WEB9ACsfVIpj6y1BqEBOjkhwUXR6mHmkm2nFBBEBkLaHQA1iBttsAHSE0lk8kANiEgO4oPBkNI0L6oIUIGWpExEL%2BpDgsCQaCMHjw7DIFAgAqFIpA6SMZkk8SowoIblZEGcWNBzjs6QAnoD0aQBUYtAQAPK0Vh6rmkLBGETAdgam14F7JABumFZ1sw0ySBmV%2BtBg2UTtYeGcxF1eiwgY5xDwRkDHRo9CYbA4PH4gmEohQcJkQnDrMgHVQHgKXoAtKaFCzEskNBArLVTPErKVorFPN5fHQW92wn4O%2BU4gl8ikGv34nkkgUihlhy1R1VilPFA1F132p1ur0uP9ASCwU6masAEoAWSGwGQyCGZiJkiJnCGEFodEwcwguEIJBRaNIIY9EFYU3H/dogPzaQMQ1HFSHxQkSXJZDCSpAE%2BlpY9rSZFk2Q5WCeRgRAQBvZB0GMDxyEoAB9CVQPjdBBGozB8CIBjBFGdAXgUBRTXLPxYzYVg%2BIKWNnFYVBkFxXj%2BI0PoDSwNJhRk0T5NBFNGBYR1MzwDxmF2CjYzDex3xEgS1NISMAHczLkg0MlYAzBVjGdVBYgAFZgeKxZYgQIIlgATDx2DrcdG2bfRskEdsmk7VoQh7Ao11CXtaE3eLXLnSdIqCad6yy4p0uXbLAlbddCtikd90UMMjFs8EDRXAgVPMg0CBeTAnI8J0DDwdB6tjN0yxauzuXQo96ShQFzyvUj70fZ9X3few5gAcR0HQhgAFQ6gB6M8tusIYADU8EwKywO/Vi/ykACgNQECRXAtoYK5OCEOJFCUOpDC6RPQFcPZTlsQPPpJD%2B7CAfwt6Og9YgfA0bggA%3D%3D"></iframe>

After we've applied optimization passes the annotations for where the statements starts are still present.
The dataflow changes are also recorded. 
Some expressions have been elided but the debug info still records how variables are mapped.
More on the dataflow later in this post.

<iframe width="800px" height="200px" src="https://godbolt.org/e?readOnly=true&hideEditorToolbars=true#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhkAUgBMAISnTSAZ0ztkBPHUqZa6AMKpWAVwC2tEAE5SW9ABk8tTADljAI0zFBAB1QLC62nsMTc1IvHzU6W3snI1d3TkVlTFU/BgJmYgIA41MLJRVw2lT0gkjHFzdBBTSMrKDc6pK7MpiKzgBKRVQDYmQOAHI7AgBqZnR0SQhBoYAPNqHxAHZZAAYAQSGNmfmAZgARLbkhznFtlfXN6Z39y8Pj0/E1zaHiTAJu2hmTs8Xdvo7WEB9ACsfVIpj6y1BqEBOjkhwUXR6mHmkm2nFBBEBkLaHQA1iBttsAHSE0lk8kANiEgO4oPBkNI0L6oIUIGWpExEL%2BpDgsCQaCMHjw7DIFAgAqFIpA6SMZkk8SowoIblZEGcWNBzjs6QAnoD0aQBUYtAQAPK0Vh6rmkLBGETAdgam14F7JABumFZ1sw0ySBmV%2BtBg2UTtYeGcxF1eiwgY5xDwRkDHRo9CYbA4PH4gmEohQcJkQnDrMgHVQHgKXoAtKaFCzEskNBArLVTPErKVorFPN5fHQW92wn4O%2BU4gl8ikGv34nkkgUihlhy1R1VilPFA1F132p1ur0uP9ASCwU6masAEoAWSGwGQyCGZiJkiJnCGEFodEwcwguEIJBRaNIIY9EFYU3H/dogPzaQMQ1HFSHxQkSXJZDCSpAE%2BlpY9rSZFk2Q5WCeRgRAQBvZB0GMDxyEoAB9CVQPjdBBGozB8CIBjBFGdAXgUBRTXLPxYzYVg%2BIKWNnFYVBkFxXj%2BI0PoDSwNJhRk0T5NBFNGBYR1MzwDxmF2CjYzDex3xEgS1NISMAHczLkg0MlYAzBVjGdVBYgAFZgeMBVFOAIIkyzUIw8AALxYutx0bZt9GyQR2yaTtWhCHsCjXUJe1oTcktcudJxioJp3rXLiiy5c8sCVt1xKhKR33RQwyMWzwQNFcCBU8yDQIF5MCcjwnQMPB0Ca2M3TLdq7O5dCj3pKFAXPK9SPvR9n1fd97DmABxHQdCGAAVbqAHoz126whgANTwTArLA79WL/KQAKA1AQJFcC2hgrk4IQ4kUJQ6kMLpE9AVw9lOWxA8%2BkkQHsOB/DPo6D1iB8DRuCAA%3D"></iframe>

And the final line mappings matches what was in the last tree optimization pass.

```
$ dwarfdump add.c
            NS new statement, BB new basic block, ET end of text sequence
            PE prologue end, EB epilogue begin
            IS=val ISA number, DI=val discriminator value
<pc>        [lno,col] NS BB ET PE EB IS= DI= uri: "filepath"
0x00000000  [   1,17] NS uri: "/home/dannas/code/rsc/2020/dwarf/linux_examples/add.c"
0x00000000  [   2, 5] NS
0x00000000  [   3, 5] NS
0x00000000  [   4, 1]
0x00000004  [   4, 1]
0x00000008  [   4, 1] ET
```

## Tail calls
If you call a function as the last statement in a function, then the call may be 

## Relabelling
TODO: Probably for another post
It would be useful to have in DWARF a way to mark where local variable is unavailable,
but is known to be unchanged from some earlier point in the code.
It would also be useful if DWARF had a tag for marking where a variable has not been initialized.

## Outlining

## Inlining
You can't get the return value of an inlined function

## Reordering

## Quality of debug info
TODO: Probably for another post

## Conclusion


<!-- Interrupt Keep START -->
{% include newsletter.html %}

{% include submit-pr.html %}
<!-- Interrupt Keep END -->

{:.no_toc}

## References

<!-- prettier-ignore-start -->
[^reference_key]: [Post Title](https://example.com)
<!-- prettier-ignore-end -->
